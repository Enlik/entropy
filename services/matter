#!/usr/bin/python

import sys
import os
import shlex
import signal
import argparse
import tempfile
import subprocess

# Entropy imports
sys.path.insert(0,'/usr/lib/entropy/libraries')
sys.path.insert(0,'/usr/lib/entropy/server')
sys.path.insert(0,'/usr/lib/entropy/client')
sys.path.insert(0,'../libraries')
sys.path.insert(0,'../server')
sys.path.insert(0,'../client')

# Entropy imports
from entropy.exceptions import PermissionDenied
from entropy.const import etpConst, etpUi
from entropy.output import print_info, print_error, print_warning, \
    purple, darkgreen
from entropy.exceptions import InvalidAtom, SPMError
from entropy.server.interfaces import Server

import entropy.tools
import entropy.dep

# Portage imports
import portage
import portage.versions

from _emerge.depgraph import backtrack_depgraph
from _emerge.actions import load_emerge_config, action_build
from _emerge.create_depgraph_params import create_depgraph_params
from _emerge.main import parse_opts, post_emerge, \
    validate_ebuild_environment
from _emerge.stdout_spinner import stdout_spinner


def get_entropy_server(repository_id, community_mode):
    """
    Return Entropy Server interface object.
    """
    return Server(community_repo = community_mode,
        default_repository = repository_id)

def exec_cmd(args, env = None):
    """
    Execute a command with given environment.
    """
    pid = os.fork()
    if pid == 0:
        if env is not None:
            os.execvpe(args[0], args, env)
        else:
            os.execvp(args[0], args)
    else:
        try:
            rcpid, rc = os.waitpid(pid, 0)
        except KeyboardInterrupt:
            rc = 1
            os.kill(pid, signal.SIGTERM)
        return rc


class EntropyResourceLock(object):
    """
    This class exposes a Lock-like interface for acquiring Entropy Server
    resources.
    """

    class NotAcquired(Exception):
        """ Raised when Entropy Resource Lock cannot be acquired """

    def __init__(self, entropy_server, blocking):
        """
        EntropyResourceLock constructor.

        @param entropy_server: Entropy Server instance
        @type entropy_server: entropy.server.interfaces.Server
        @param blocking: acquire lock in blocking mode?
        @type blocking: bool
        """
        self._entropy = entropy_server
        self._blocking = blocking
        self.__inside_with_stmt = 0

    def acquire(self):
        acquired = entropy.tools.acquire_entropy_resources_locks(self._entropy,
            blocking = self._blocking)
        if not acquired:
            raise EntropyResourceLock.NotAcquired("unable to acquire lock")

    def release(self):
        entropy.tools.release_entropy_locks(self._entropy)

    def __enter__(self):
        """
        Acquire lock. Not thread-safe.
        """
        if self.__inside_with_stmt < 1:
            self.acquire()
        self.__inside_with_stmt += 1
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        """
        Release lock. Not thread-safe.
        """
        self.__inside_with_stmt -= 1
        if self.__inside_with_stmt < 1:
            self.release()


class PackageBuilder(object):
    """
    Portage Package builder class
    """

    DEFAULT_PORTAGE_SYNC_CMD = "emerge --sync"
    PORTAGE_SYNC_CMD = shlex.split(os.getenv("BUILDER_PORTAGE_SYNC_CMD",
        DEFAULT_PORTAGE_SYNC_CMD))

    DEFAULT_OVERLAYS_SYNC_CMD = "layman -S"
    OVERLAYS_SYNC_CMD = shlex.split(os.getenv("BUILDER_OVERLAYS_SYNC_CMD",
        DEFAULT_OVERLAYS_SYNC_CMD))

    DEFAULT_PORTAGE_BUILD_ARGS = "--verbose --nospinner"
    PORTAGE_BUILD_ARGS = os.getenv("BUILDER_PORTAGE_BUILD_ARGS",
        DEFAULT_PORTAGE_BUILD_ARGS).split()

    def __init__(self, entropy_server, package, params):
        self._entropy = entropy_server
        self._package = package
        self._params = params

    @staticmethod
    def _build_standard_environment(repository):
        env = os.environ.copy()
        env["BUILDER_REPOSITORY_ID"] = repository
        return env

    @staticmethod
    def setup(executable_hook_f, cwd, repository):
        hook_name = executable_hook_f.name
        if not hook_name.endswith("/"):
            # complete with current directory
            hook_name = os.path.join(cwd, hook_name)

        print_info("spawning pre hook: %s" % (hook_name,))
        return exec_cmd([hook_name],
            env = PackageBuilder._build_standard_environment(repository))

    @staticmethod
    def teardown(executable_hook_f, cwd, repository, exit_st):
        hook_name = executable_hook_f.name
        if not hook_name.endswith("/"):
            # complete with current directory
            hook_name = os.path.join(cwd, hook_name)

        print_info("spawning post hook: %s, passing exit status: %d" % (
            hook_name, exit_st,))
        env = PackageBuilder._build_standard_environment(repository)
        env["BUILDER_EXIT_STATUS"] = str(exit_st)
        return exec_cmd([hook_name], env = env)

    def run(self):
        """
        Execute Package building action.
        """
        print_info(
            "spawning package build: %s" % (self._package,))

        # ignore exit status
        subprocess.call(["env-update"])

        std_env = PackageBuilder._build_standard_environment(
            self._params.repository)
        std_env["BUILDER_PACKAGE_NAME"] = self._package
        print_info("BUILDER_PACKAGE_NAME = %s" % (self._package,))

        # run pkgpre, if any
        pkgpre = self._params.pkgpre
        if pkgpre is not None:
            print_info(
                "spawning --pkgpre: %s, name: %s" % (pkgpre, pkgpre.name))
            tmp_fd, tmp_path = tempfile.mkstemp(prefix="matter")
            with os.fdopen(tmp_fd, "wb") as tmp_f:
                tmp_f.write(pkgpre.read())
            try:
                # now execute
                os.chmod(tmp_path, 0o700)
                exit_st = exec_cmd([tmp_path], env = std_env)
                if exit_st != 0:
                    return exit_st
            finally:
                os.remove(tmp_path)

        # execute the update code
        exit_st = self._run_builder(std_env)
        if exit_st != 0:
            return exit_st

        # run pkgpre, if any
        pkgpost = self._params.pkgpost
        if pkgpost is not None:
            print_info(
                "spawning --pkgpost: %s, name: %s" % (pkgpost, pkgpost.name))
            tmp_fd, tmp_path = tempfile.mkstemp(prefix="matter")
            with os.fdopen(tmp_fd, "wb") as tmp_f:
                tmp_f.write(pkgpost.read())
            try:
                # now execute
                os.chmod(tmp_path, 0o700)
                exit_st = exec_cmd([tmp_path], env = std_env)
                if exit_st != 0:
                    return exit_st
            finally:
                os.remove(tmp_path)

        # so far, so good
        return 0

    def _run_builder(self, env):
        """
        This method is called by _run and executes the whole package build
        logic, including constraints validation given by argv parameters.
        """
        portdb = portage.portdb
        portdb.freeze()
        settings = portage.config(clone=portage.settings)
        vardb = portage.db[settings["ROOT"]]["vartree"].dbapi
        fakedb = portage.fakedbapi(settings=portage.settings)

        # Load the most current variables from /etc/profile.env, which
        # has been re-generated by the env-update call in _run()
        settings.unlock()
        settings.reload()
        settings.regenerate()
        settings.lock()

        best_visible = portdb.xmatch("bestmatch-visible", self._package)
        if not best_visible:
            # package not found, return error
            print_error("cannot match: %s, aborting" % (self._package,))
            return 1

        print_info("matched: %s for %s" % (best_visible, self._package,))
        # now determine what's the installed version.
        best_installed = portage.best(vardb.match(self._package))
        if not best_installed:
            # package not installed, behaviour not supported atm
            print_error("package not installed: %s, aborting" % (
                self._package,))
            return 1

        print_info("found installed: %s for %s" % (best_installed,
            self._package,))

        # now compare
        # -1 if best_installed is older than best_visible
        # 1 if best_installed is newer than best_visible
        # 0 if they are equal
        cmp_res = portage.versions.pkgcmp(
            portage.versions.pkgsplit(best_installed),
            portage.versions.pkgsplit(best_visible))

        if (cmp_res == 1) and not self._params.downgrade:
            # downgrade in action and downgrade not allowed, aborting!
            print_error(
                "package: %s, would be downgraded from %s to %s, aborting" % (
                    self._package, best_installed, best_visible,))
            return 1

        if (cmp_res == 0) and not self._params.rebuild:
            # rebuild in action and rebuild not allowed, aborting!
            print_error(
                "package: %s, would be rebuilt to %s, aborting" % (
                    self._package, best_visible,))
            return 1

        # at this point we can go ahead building self._package
        print_info("starting to build: %s, to %s" % (self._package,
            best_visible,))

        print_info("portage modules loaded with success")

        emerge_settings, emerge_trees, mtimedb = \
            load_emerge_config(trees=portage.db)
        myaction, myopts, myfiles = parse_opts(
            PackageBuilder.PORTAGE_BUILD_ARGS + ["="+best_visible])
        spinner = None
        if ("--quiet" not in myopts) or ("--nospinner" in myopts):
            spinner = stdout_spinner()
        params = create_depgraph_params(myopts, myaction)
        success, graph, favorites = backtrack_depgraph(emerge_settings,
            emerge_trees, myopts, params, myaction, myfiles, spinner)

        if not success:
            # print issues to stdout and give up
            print_error("dependencies calculation failed for %s, aborting" % (
                best_visible,))
            graph.display_problems()
            return 1
        print_info("dependency graph generated successfully")

        # list of _emerge.Package.Package objects
        package_queue = graph.altlist()
        dep_list = [p.cpv+"::"+p.repo for p in package_queue]

        # calculate dependencies, if --dependencies is not enabled
        # because we have to validate it
        if (not self._params.dependencies) and (len(package_queue) > 1):
            # package is pulling in dependencies, but --dependencies is not
            # enabled. need to give up
            deps = ", ".join(dep_list)
            print_error(
                "package %s is pulling in: %s, but --dependencies "
                "not specified, aborting" % (best_visible, deps,))
            return 1

        print_info("about to build the following packages:")
        for dep in dep_list:
            print_info("  %s" % (dep,))

        # re-calling action_build(), deps are re-calculated though
        validate_ebuild_environment(emerge_trees)
        retval = action_build(emerge_settings, emerge_trees, mtimedb,
            myopts, myaction, myfiles, spinner)

        # NOTE: this is a WORKAROUND for Portage's post_emerge() calling
        # sys.exit() at the end.
        sys_exit = sys.exit
        sys.exit = lambda x: None
        post_emerge(myaction, myopts, myfiles, emerge_settings["ROOT"],
            emerge_trees, mtimedb, retval)
        sys.exit = sys_exit

        print_info("portage spawned, return value: %d" % (retval,))

        return retval

    @staticmethod
    def sync(repository):
        """
        Execute Portage and Overlays sync
        """
        sync_cmd = PackageBuilder.PORTAGE_SYNC_CMD
        std_env = PackageBuilder._build_standard_environment(
            repository)
        rc = exec_cmd(sync_cmd, env = std_env)
        if rc != 0:
            return rc

        # overlays update
        overlay_cmd = PackageBuilder.OVERLAYS_SYNC_CMD
        return exec_cmd(overlay_cmd, env = std_env)

    @staticmethod
    def commit(entropy_server, repository, packages):
        """
        Commit packages to Entropy repository.
        """
        spm = entropy_server.Spm()
        spm_atoms = set()
        exit_st = 0

        print_info("committing packages: %s, to repository: %s" % (
            ", ".join(sorted(packages)), repository,))

        # if we get here, something has been compiled
        # successfully
        for package in completed:
            try:
                spm_atom = spm.match_installed_package(package)
                spm_atoms.add(spm_atom)
            except InvalidAtom:
                exit_st = 1
                print_warning(
                    "cannot find installed package: %s" % (
                        package,))
                continue

        if not spm_atoms:
            return exit_st

        print_info("about to commit:")
        spm_packages = sorted(spm_atoms)

        for atom in spm_packages:
            item_txt = atom

            # this is a spm atom
            spm_key = entropy.dep.dep_getkey(atom)
            try:
                spm_slot = spm.get_installed_package_metadata(
                    atom, "SLOT")
                spm_repo = spm.get_installed_package_metadata(
                    atom, "repository")
            except KeyError:
                spm_slot = None
                spm_repo = None

            etp_repo = None
            if spm_repo is not None:
                pkg_id, repo_id = entropy_server.atom_match(spm_key,
                    match_slot = spm_slot)
                if repo_id != 1:
                    repo_db = entropy_server.open_repository(repo_id)
                    etp_repo = repo_db.retrieveSpmRepository(pkg_id)

                    if (etp_repo is not None) and (etp_repo != spm_repo):
                        item_txt += ' [%s {%s=>%s}]' % ("warning",
                            etp_repo, spm_repo,)

            print_info(item_txt)

        # always stuff new configuration files here
        # if --gentle was specified, the uncommitted stuff here belongs
        # to our packages.
        # if --gentle was NOT specified, we just don't give a shit
        uncommitted = entropy_server._check_config_file_updates()
        if uncommitted:
            subprocess.call("echo -5 | etc-update", shell = True)
        # test again
        uncommitted = entropy_server._check_config_file_updates()
        if uncommitted:
            # ouch, wtf? better aborting
            print_error("tried to commit configuration file changes and failed")
            return 1

        print_info("about to compress:")

        store_dir = entropy_server._get_local_store_directory(repository)
        package_paths = []
        for atom in spm_packages:
            print_info(atom)
            try:
                package_path = spm.generate_package(atom, store_dir)
            except OSError:
                entropy.tools.print_traceback()
                print_error("problem during package generation, aborting")
                return 1
            except SPMError:
                entropy.tools.print_traceback()
                print_error("problem during package generation (2), aborting")
                return 1
            package_paths.append(package_path)

        etp_pkg_files = [(x, False) for x in package_paths]
        # NOTE: any missing runtime dependency will be added
        # (beside those blacklisted), since this execution is not interactive
        package_ids = entropy_server.add_packages_to_repository(
            repository, etp_pkg_files, ask = False)
        if package_ids:
            # checking dependencies and print issues
            entropy_server.dependencies_test(repository)
        entropy_server.close_repositories()

        return exit_st

    @staticmethod
    def push(entropy_server, repository):
        """
        Push staged packages in repository to online Entropy mirrors.
        """
        rc = PackageBuilder._push_packages(entropy_server, repository)
        if rc != 0:
            return rc
        rc = PackageBuilder._push_repository(entropy_server, repository)
        return rc

    @staticmethod
    def _push_packages(entropy_server, repository):
        """
        Upload newly built packages.
        """
        mirrors_tainted, mirrors_errors, successfull_mirrors, \
            broken_mirrors, check_data = \
                entropy_server.Mirrors.sync_packages(
                    repository, ask = False, pretend = False)
        if mirrors_errors and not successfull_mirrors:
            return 1
        return 0

    @staticmethod
    def _push_repository(entropy_server, repository):
        """
        Update remote repository.
        """
        sts = entropy_server.Mirrors.sync_repository(repository_id)
        return sts



if __name__ == "__main__":

    ENV_VARS_HELP = """\

Environment variables always exported into children:
%s      =  repository identifier

Environment variables for Package Builder module:
%s   =  alternative command used to sync Portage
                              default: %s
%s  =  alternative command used to sync Portage overlays
                              default: %s
%s  = custom emerge arguments
                              default: %s

Environment variables passed to --post executables:
%s        = exit status from previous execution phases, useful for detecting
                             execution errors.

Environment variables passed to --pkgpre/--pkgpost executables:
%s       = name of the package that would be built

""" % (
        purple("BUILDER_REPOSITORY_ID"),
        purple("BUILDER_PORTAGE_SYNC_CMD"),
        darkgreen(PackageBuilder.DEFAULT_PORTAGE_SYNC_CMD),
        purple("BUILDER_OVERLAYS_SYNC_CMD"),
        darkgreen(PackageBuilder.DEFAULT_OVERLAYS_SYNC_CMD),
        purple("BUILDER_PORTAGE_BUILD_ARGS"),
        darkgreen(PackageBuilder.DEFAULT_PORTAGE_BUILD_ARGS),
        purple("BUILDER_EXIT_STATUS"),
        purple("BUILDER_PACKAGE_NAME"),)

    parser = argparse.ArgumentParser(
        description='Automated Portage Package Builder',
        epilog=ENV_VARS_HELP,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("repository", metavar="<repository>",
        help="Entropy Repository where to stash new packages")

    # * instead of + in order to support --sync only tasks
    parser.add_argument("package", nargs='*', metavar="<package>",
        help="package dependency to build")

    parser.add_argument("--blocking",
        help="when trying to acquire Entropy Server locks, block until success",
        action="store_true")

    parser.add_argument("--community",
        help="enforce Community Repository mode on Entropy Server",
        action="store_true")

    parser.add_argument("--debug",
        help="print debug output",
        action="store_true")

    parser.add_argument("--dependencies",
        help="allow dependencies to be pulled in, if required",
        action="store_true")

    parser.add_argument("--downgrade",
        help="allow package downgrade, if required",
        action="store_true")

    parser.add_argument("--gentle",
        help="do not run if staged packages are present in Entropy repository",
        action="store_true")

    parser.add_argument("--keep-going",
        help="keep going if any of the target packages failed to be updated",
        action="store_true")

    parser.add_argument("--push",
        help="push entropy package updates to online repository",
        action="store_true")

    parser.add_argument("--rebuild",
        help="rebuild the package despite being already up-to-date",
        action="store_true")

    parser.add_argument("--pkgpre", metavar="<exec>", type=file,
        help="executable to be called before package building",
        default=None)

    parser.add_argument("--pkgpost", metavar="<exec>", type=file,
        help="executable to be called after package building",
        default=None)

    parser.add_argument("--pre", metavar="<exec>", type=file,
        help="executable to be called once for setup purposes",
        default=None)

    parser.add_argument("--post", metavar="<exec>", type=file,
        help="executable to be called once for teardown purposes",
        default=None)

    parser.add_argument("--sync",
        help="sync Portage tree, and attached overlays, before starting",
        action="store_true")

    nsargs = parser.parse_args(sys.argv[1:])

    if os.getuid() != 0:
        # root access required
        sys.stderr.write("superuser access required\n")
        raise SystemExit(1)

    if nsargs.community:
        etpConst['community']['mode'] = True

    if nsargs.debug:
        print_warning(repr(nsargs))
        # if just one, drop from argv, so that it doesn't interfere with
        # entropy --debug support
        if sys.argv.count("--debug") < 2:
            etpUi['debug'] = False

    entropy_server = None
    repository_id = nsargs.repository
    exit_st = 0
    cwd = os.getcwd()

    try:
        try:
            entropy_server = get_entropy_server(repository_id,
                etpConst['community']['mode'])
        except PermissionDenied:
            # repository not available or not configured
            print_error("<repository> is not a valid server-side repository")
            raise SystemExit(3)

        with EntropyResourceLock(entropy_server, nsargs.blocking):

            if nsargs.gentle:
                # check if there is something to do
                to_be_added, to_be_removed, to_be_injected = \
                    entropy_server.scan_package_changes()
                if to_be_added: # only check this, others we can ignore
                    to_be_added = [x[0] for x in to_be_added]
                    to_be_added.sort()
                    print_error("--gentle specified, and unstaged packages found:")
                    for name in to_be_added:
                        print_warning("  " + name)
                    raise SystemExit(5)

                # also check for uncommitted configuration files changed
                problems = entropy_server._check_config_file_updates()
                if problems:
                    print_error(
                        "some configuration files have to be merged manually")
                    raise SystemExit(6)

            # setup
            if nsargs.pre:
                rc = PackageBuilder.setup(nsargs.pre, cwd, nsargs.repository)
                if rc != 0:
                    exit_st = rc

            if exit_st == 0:

                if nsargs.sync:
                    rc = PackageBuilder.sync(nsargs.repository)
                    if rc != 0:
                        exit_st = rc

                if (exit_st == 0) or nsargs.keep_going:
                    completed = []
                    for package in nsargs.package:
                        builder = PackageBuilder(entropy_server, package,
                            nsargs)
                        rc = builder.run()
                        if rc == 0:
                            completed.append(package)
                        else:
                            exit_st = rc
                            if not nsargs.keep_going:
                                break

                    # portage calls setcwd()
                    os.chdir(cwd)

                    if completed:
                        rc = PackageBuilder.commit(entropy_server,
                            nsargs.repository, completed)
                        if exit_st == 0 and rc != 0:
                            exit_st = rc

                        if rc == 0 and nsargs.push:
                            rc = PackageBuilder.push(entropy_server,
                                nsargs.repository)
                            if exit_st == 0 and rc != 0:
                                exit_st = rc

            if nsargs.post:
                rc = PackageBuilder.teardown(nsargs.post, cwd,
                    nsargs.repository, exit_st)
                if exit_st == 0 and rc != 0:
                    exit_st = rc

    except EntropyResourceLock.NotAcquired:
        print_error("unable to acquire Entropy Resources lock")
        raise SystemExit(42)
    finally:
        if entropy_server is not None:
            entropy_server.shutdown()

    print_warning("")
    print_warning("")
    print_warning("Tasks complete, exit status: %d" % (exit_st,))
    raise SystemExit(exit_st)


