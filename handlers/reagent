#!/usr/bin/python
# Copyright Fabio Erculiani - Sabayon Linux 2007

# DESCRIPTION:
# this application gets a .tbz2 file as input and creates the dependency binary metafile
# that another application could handle using portage and binpackages extensions directly

import os
import sys
import string

sys.path.append('../libraries')
import entropyTools
from entropyConstants import *

# CONSTANTS
APPNAME = "reagent"
APPVERSION = "1.0"
def print_help():
    print "* info  * : Sabayon Linux "+APPNAME+" (C - 2007)"
    print
    print "* usage * : "+APPNAME+" <tool, not mandatory> <valid path or .tbz2 file>"
    print "* opts  * : --help\t\tthis output"
    print "* opts  * : --version\t\tprint version"
    print
    print "* info  * : tools available: "
    print "* info  * : \tdigest\t to create digest of a specified directory"
    print

options = sys.argv[1:]

# print version
if (string.join(options).find("--version") != -1) or (string.join(options).find(" -V") != -1):
    entropyTools.print_generic(APPNAME+": "+APPVERSION)
    sys.exit(0)

# print help
if len(options) < 1 or string.join(options).find("--help") != -1 or string.join(options).find(" -h") != -1:
    print_help()
    if len(options) < 1:
	entropyTools.print_error("not enough parameters")
    sys.exit(1)

# digest tool (creates a digest on the specified directory)
if (options[0].find("digest") != -1):
    entropyTools.createDigest(options[1])
    sys.exit(0)
# add other options here
# ...
# ...
# tbz2 tool
if (not options[0].endswith(".tbz2")):
    entropyTools.print_error("no .tbz2 file specified")
    sys.exit(3)

validFile = False
for i in options:
    if os.path.isfile(i) and i.endswith(".tbz2"):
	validFile = True
	tbz2File = i
	break

if (not validFile):
    entropyTools.print_error("no valid .tbz2 file specified")
    sys.exit(4)


entropyTools.print_info("extracting data and calculating info for: "+tbz2File.split("/")[len(tbz2File.split("/"))-1]+" please wait...")
# fill all the info
etpData = entropyTools.extractPkgData(tbz2File)

# look where I can store the file and return its path
etpOutput, etpOutfilePath = entropyTools.allocateFile(etpData)

if etpOutfilePath is not None:
    entropyTools.print_info("writing: "+etpOutfilePath)
    f = open(etpOutfilePath,"w")
    f.writelines(etpOutput)
    f.flush()
    f.close()
    # digesting directory
    entropyTools.createDigest(etpOutfilePath)
else:
    entropyTools.print_info("not generating a new .etp file, it's not needed")

# clean garbage
os.system("rm -rf "+etpConst['packagestmpdir']+"/"+etpData['name']+"-"+etpData['version'])