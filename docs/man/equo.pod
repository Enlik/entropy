
=head1 NAME

B<equo> - Official Sabayon Linux Package Manager Client

=head1 SYNOPSIS

B<equo> [action] [basic_options] [options|extended_options] [atom | package_file | @set] ...

B<equo> [action] [basic_options] [options|extended_options] ...

B<equo> --info

B<equo> --help

B<equo> --version

=head1 DESCRIPTION

B<equo> is the definitive (rofl)... scratch it.
B<equo> is the official command-line interface to the Entropy framework. Primarily
used to ease packages management on Gentoo-based, Entropy-enabled distributions.

With B<equo> you can easily install and remove any application inside available and
enabled repositories: it's a binary package manager which brings the best from
apt, yum and rpm, keeping 100% backward Portage (see 'man emerge') compatibility.
Being Entropy a framework means that it's not just ended here.

For example, through B<equo> you can build your own software repository (called
Community Repository), do searches, keep your system secure, download packages'
source code, sanity check your system, see and be part of the User Generated
Content produced by other users.

=head1 BASIC_OPTIONS

=over

=item [1] B<--help>

this output

=item [1] B<--version>

print version

=item [1] B<--nocolor>

disable colorized output

=item [1] B<--color>

force colorized output

=item [1] B<--bashcomp>

print a bash completion script to stdout


=back

=head1 OPTIONS

=over

=item [1] B<update>

update configured repositories


=over

=item [2] B<--force>

force sync regardless repositories status


=back

=item [1] B<repo>

manage your repositories


=over

=item [2] B<enable>

enable given repository

=item [2] B<disable>

disable given repository

=item [2] B<add E<lt>stringE<gt>>

add repository (pass repository string)

=item [2] B<remove E<lt>idE<gt>>

remove repository

=item [2] B<list>

list active repositories

=item [2] B<mirrorsort E<lt>idE<gt>>

reorder mirrors basing on response time

=item [2] B<merge [sources] E<lt>destE<gt>>

merge content of source repos to dest [for developers]


=over

=item [3] B<--conflicts>

also remove dependency conflicts during merge


=back


=back

=item [1] B<notice [repos]>

repository notice board reader

=item [1] B<status>

show respositories status

=item [1] B<search>

search packages in repositories

=item [1] B<match>

match a package in repositories


=over

=item [2] B<--multimatch>

return all the possible matches

=item [2] B<--installed>

match inside installed packages repository

=item [2] B<--multirepo>

return matches from every repository

=item [2] B<--showrepo>

print repository information (w/--quiet)

=item [2] B<--showdesc>

print description too (w/--quiet)


=back

=item [1] B<hop E<lt>branchE<gt>>

upgrade your distribution to a new release (branch)

=item [1] B<upgrade>

update system with the latest available packages


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--fetch>

just download packages

=item [2] B<--pretend>

only show what would be done

=item [2] B<--verbose>

show more details about what is going on

=item [2] B<--replay>

reinstall all the packages and their dependencies

=item [2] B<--empty>

same as --replay

=item [2] B<--resume>

resume previously interrupted operations

=item [2] B<--skipfirst>

used with --resume, makes the first package to be skipped

=item [2] B<--multifetch>

download multiple packages in parallel (default 3)

=item [2] B<--multifetch=N>

download N packages in parallel (max 10)


=back

=item [1] B<security>

security infrastructure functions


=over

=item [2] B<oscheck>

verify installed files using stored checksums


=over

=item [3] B<--mtime>

consider mtime instead of SHA256 (false positives ahead)

=item [3] B<--assimilate>

update hashes and mtime (useful after editing config files)

=item [3] B<--reinstall>

reinstall faulty packages

=item [3] B<--quiet>

show less details (useful for scripting)

=item [3] B<--verbose>

also list removed files


=back

=item [2] B<update>

download the latest Security Advisories


=over

=item [3] B<--force>

force download even if already up-to-date


=back

=item [2] B<list>

list all the available Security Advisories


=over

=item [3] B<--affected>

list only affected

=item [3] B<--unaffected>

list only unaffected


=back

=item [2] B<info>

show information about provided advisories identifiers

=item [2] B<install>

automatically install all the available security updates


=over

=item [3] B<--ask>

ask before making any changes

=item [3] B<--fetch>

just download packages

=item [3] B<--pretend>

just show what would be done

=item [3] B<--quiet>

show less details (useful for scripting)


=back


=back

=item [1] B<install>

install atoms or binary packages


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done

=item [2] B<--fetch>

just download packages without doing the install

=item [2] B<--nodeps>

do not pull in any dependency

=item [2] B<--bdeps>

also pull in build-time dependencies

=item [2] B<--resume>

resume previously interrupted operations

=item [2] B<--skipfirst>

used with --resume, makes the first package in queue to be skipped

=item [2] B<--clean>

remove downloaded packages after being used

=item [2] B<--empty>

pull all the dependencies in, regardless their state

=item [2] B<--relaxed>

calm down dependencies resolution algorithm (might be risky)

=item [2] B<--deep>

makes dependency rules stricter

=item [2] B<--verbose>

show more details about what is going on

=item [2] B<--configfiles>

makes old configuration files to be removed

=item [2] B<--multifetch>

download multiple packages in parallel (default 3)

=item [2] B<--multifetch=N>

download N packages in parallel (max 10)


=back

=item [1] B<source>

download atoms source code


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done

=item [2] B<--nodeps>

do not pull in any dependency

=item [2] B<--relaxed>

calm down dependencies resolution algorithm (might be risky)

=item [2] B<--savehere>

save sources in current working directory


=back

=item [1] B<fetch>

just download packages without doing the install


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done

=item [2] B<--nodeps>

do not pull in any dependency

=item [2] B<--relaxed>

calm down dependencies resolution algorithm (might be risky)

=item [2] B<--multifetch>

download multiple packages in parallel (default 3)

=item [2] B<--multifetch=N>

download N packages in parallel (max 10)


=back

=item [1] B<remove>

remove one or more packages


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done

=item [2] B<--nodeps>

do not pull in any dependency

=item [2] B<--deep>

also pull unused dependencies where reverse deps list is empty

=item [2] B<--empty>

when used with --deep, helps the removal of virtual packages

=item [2] B<--configfiles>

makes configuration files to be removed

=item [2] B<--force-system>

dangerous: forces system packages removal, do not use this!

=item [2] B<--resume>

resume previously interrupted operations


=back

=item [1] B<mask>

mask one or more packages


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done


=back

=item [1] B<unmask>

unmask one or more packages


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done


=back

=item [1] B<config>

configure one or more installed packages


=over

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done


=back

=item [1] B<deptest>

look for unsatisfied dependencies


=over

=item [2] B<--quiet>

show less details (useful for scripting)

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done


=back

=item [1] B<unusedpackages>

look for unused packages (pay attention)


=over

=item [2] B<--quiet>

show less details (useful for scripting)

=item [2] B<--sortbysize>

sort packages by disk size


=back

=item [1] B<libtest>

look for missing libraries


=over

=item [2] B<--dump>

dump results to files

=item [2] B<--listfiles>

print broken files to stdout

=item [2] B<--quiet>

show less details (useful for scripting)

=item [2] B<--ask>

ask before making any changes

=item [2] B<--pretend>

just show what would be done


=back

=item [1] B<conf>

configuration files update tool


=over

=item [2] B<update>

run the configuration files update function


=back

=item [1] B<query>

do misc queries on repository and local databases


=over

=item [2] B<belongs>

search from what package a file belongs

=item [2] B<changelog>

show packages changelog

=item [2] B<revdeps>

search what packages depend on the provided atoms

=item [2] B<description>

search packages by description

=item [2] B<files>

show files owned by the provided atoms

=item [2] B<installed>

search a package into the local database

=item [2] B<license>

show packages owning the provided licenses

=item [2] B<list>

list packages based on the chosen parameter below


=over

=item [3] B<installed> [repo]

list installed packages


=over

=item [4] B<--by-user>

only packages installed by user


=back

=item [3] B<available [repos]>

list available packages


=back

=item [2] B<mimetype>

search packages able to handle given mimetypes


=over

=item [3] B<--installed>

search among installed packages


=back

=item [2] B<associate>

associate given file paths to applications able to read them


=over

=item [3] B<--installed>

search among installed packages


=back

=item [2] B<needed>

show runtime libraries needed by the provided atoms

=item [2] B<orphans>

search files that do not belong to any package

=item [2] B<removal>

show the removal tree for the specified atoms

=item [2] B<required>

show atoms needing the provided libraries

=item [2] B<sets>

search available package sets

=item [2] B<slot>

show packages owning the provided slot

=item [2] B<tags>

show packages owning the provided tags

=item [2] B<graph>

show direct depdendencies tree for provided installable atoms


=over

=item [3] B<--complete>

include system packages, build deps and circularity information


=back

=item [2] B<revgraph>

show reverse depdendencies tree for provided installed atoms


=over

=item [3] B<--complete>

include system packages, build deps and circularity information


=back

=item [2] B<--verbose>

show more details

=item [2] B<--quiet>

print results in a scriptable way


=back


=back

=head1 EXTENDED_OPTIONS

=over

=item [1] B<smart>

handles extended functionalities


=over

=item [2] B<package>

make a smart package for the provided atoms (multiple packages into one file)

=item [2] B<quickpkg>

recreate an Entropy package from your System


=over

=item [3] B<--savedir>

save new packages into the specified directory


=back

=item [2] B<inflate>

convert provided Source Package Manager package files into Entropy packages


=over

=item [3] B<--savedir>

save new packages into the specified directory


=back

=item [2] B<deflate>

convert provided Entropy packages into Source Package Manager ones


=over

=item [3] B<--savedir>

save new packages into the specified directory


=back

=item [2] B<extract>

extract Entropy metadata from provided Entropy package files


=over

=item [3] B<--savedir>

save new metadata into the specified directory


=back


=back

=item [1] B<rescue>

contains System rescue tools


=over

=item [2] B<check>

check installed packages repository for errors

=item [2] B<vacuum>

remove installed packages repository internal indexes to save disk space

=item [2] B<generate>

generate installed packages database using Source Package Manager repositories

=item [2] B<resurrect>

generate installed packages database using files on the system [last hope]

=item [2] B<spmuids>

regenerate SPM UIDs map (SPM E<lt>-E<gt> Entropy packages)

=item [2] B<spmsync>

makes Entropy aware of your Source Package Manager updated packages

=item [2] B<backup>

backup the current Entropy installed packages database

=item [2] B<restore>

restore a previously backed up Entropy installed packages database


=back

=item [1] B<ugc>

handles User Generated Content features


=over

=item [2] B<login E<lt>repositoryE<gt>>

login against a specified repository

=item [2] B<logout E<lt>repositoryE<gt>>

logout from a specified repository


=over

=item [3] B<--force>

force action


=back

=item [2] B<documents E<lt>repositoryE<gt>>

manage package documents for the selected repository (comments, files, videos)


=over

=item [3] B<get E<lt>pkgkeyE<gt>>

get available documents for the specified package key (example: x11-libs/qt)

=item [3] B<add E<lt>pkgkeyE<gt>>

add a new document to the specified package key (example: x11-libs/qt)

=item [3] B<remove E<lt>docs idsE<gt>>

remove documents from database using their identifiers


=back

=item [2] B<vote E<lt>repositoryE<gt>>

manage package votes for the selected repository


=over

=item [3] B<get E<lt>pkgkeyE<gt>>

get vote for the specified package key (example: x11-libs/qt)

=item [3] B<add E<lt>pkgkeyE<gt>>

add vote for the specified package key (example: x11-libs/qt)


=back


=back

=item [1] B<cache>

handles Entropy cache


=over

=item [2] B<clean>

clean Entropy cache

=item [2] B<--verbose>

show more details

=item [2] B<--quiet>

print results in a scriptable way


=back

=item [1] B<cleanup>

remove downloaded packages and clean temp. directories

=item [1] B<--info>

show system information


=back

=head1 ENVIRONMENT

B<ETP_NOCACHE>=1: if set, all the Entropy framework will never use its internal
on-disk cache.


B<FORCE_EAPI>=N: if set to 1, 2 or 3 and used with 'B<equo> update', Entropy
repository synchronized will be force to use the provided EAPI to update
repositories.

B<ACCEPT_LICENSE>=license_id1:license_id2:...: this is a way to avoid equo
asking to accept specific licenses.

B<ETP_NO_COLOR>=1: disable entropy coloured output.

=head1 BUGS

Please report bugs to http://bugs.sabayonlinux.org.
B<equo> has a nice bug-reporting feature: whenever a valid exception occurs, it
asks the user to automatically submit the issue. B<WARNING>: to do efficient bug
squashing, some hardware specs are going to be collected, ask wrote before
submitting any data. No personal data is going to be uploaded and your report
will be kept private.

=head1 EXAMPLES

 work in progress

=head1 EXIT STATUS

B<equo> returns a zero exit status if the called command succeeded. Non zero is
returned in case of failure.

=head1 AUTHOR

Fabio Erculiani <lxnay@sabayon.org>

=head1 SEE ALSO

reagent(1), activator(1)
